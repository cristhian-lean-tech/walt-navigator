import json
from typing import Dict, List, Optional, Any
from numpy import dot
from numpy.linalg import norm

from langchain_community.chat_models import ChatOpenAI
from langchain.prompts import PromptTemplate
from langchain.chains import LLMChain
from langchain.memory import ConversationBufferMemory
from langchain.chains import ConversationChain
import os

from app.shared.const import CollectionName
from .embdding import EmbeddingService
from .text_normalizer import TextNormalizer
from .conversation_manager import ConversationManager
from app.shared.paths import PATHS
from app.shared.forms import FORMS

llm = ChatOpenAI(temperature=0, model="gpt-3.5-turbo", openai_api_key=os.environ.get("OPENAI_API_KEY"))

prompt = PromptTemplate(
    input_variables=["user_input"],
    template="""
Clasifica la siguiente solicitud en una de las siguientes categor√≠as:
- BENEFICIO: si el usuario desea pedir vacaciones, d√≠as libres, gimnasio, etc.
- EMPRESA: si el usuario pregunta sobre la empresa, jefe, pol√≠ticas, etc.
- OTRO: si no pertenece a ninguna de las anteriores.

Mensaje: "{user_input}"
Respuesta (solo la categor√≠a):
"""
)

intent_classifier = LLMChain(llm=llm, prompt=prompt)

sessions = {}
user_states: Dict[str, Dict[str, Any]] = {}
benefit_sessions: Dict[str, Dict[str, Any]] = {}

class NavigationService():

    def __init__(self):
        self.memory = ConversationBufferMemory()
        self.embedding_service = EmbeddingService()
        self.text_normalizer = TextNormalizer()
        self.conversation_manager = ConversationManager()
        self.benefit_embeddings = {}
        self.benefit_synonyms = self._init_benefit_synonyms()
        self._init_benefit_embeddings()  # Inicializar embeddings al crear la instancia
    
    def detect_user_intent(self, content: str, user_id: str) -> Optional[str]:
        result = intent_classifier.run(content)
        session = self.get_user_session(user_id)
        response = session.run(content)
        return result, response

    def get_user_session(self, user_id: str):
        if user_id not in sessions:
            sessions[user_id] = ConversationChain(
                llm=ChatOpenAI(temperature=0, model="gpt-3.5-turbo", openai_api_key=os.environ.get("OPENAI_API_KEY")),
                memory=ConversationBufferMemory(return_messages=True),
                verbose=False
            )
        return sessions[user_id]
    
    def process_user_input(self, user_id: str, content: str) -> str:
        intent, chat_response = self.detect_user_intent(content, user_id)
        current_state = user_states.get(user_id)

        if current_state and current_state["intent"] != intent:
            # El usuario cambi√≥ de intenci√≥n (empresa ‚ûù beneficio o viceversa)
            user_states[user_id] = {"intent": intent}
        
        if intent == "BENEFICIO":
            return self.handle_benefit_flow(user_id, content)
        
        elif intent == "EMPRESA":
            return chat_response  # ya viene con contexto
        
        else:
            return "Lo siento, no puedo ayudarte con eso todav√≠a üòÖ."

    def _get_benefit_config(self, content: str):
        content = content.lower()
        for item in PATHS:
            if item["description"].lower() in content or any(p in content for p in item["description"].lower().split()):
                return item
        return None

    def handle_benefit_flow(self, user_id: str, content: str) -> str:
        session = self.benefit_sessions.get(user_id)

        if not session:
            benefit_config = self._get_benefit_config(content)
            if not benefit_config:
                return "¬øQu√© beneficio deseas solicitar? Por ejemplo: vacaciones, gimnasio, educaci√≥n..."

            self.benefit_sessions[user_id] = {
                "benefit": benefit_config["description"],
                "path": benefit_config["path"],
                "fields": {},
                "parametros": benefit_config.get("parametros", [])
            }

            if not benefit_config.get("parametros"):
                del self.benefit_sessions[user_id]
                return f"‚úÖ Puedes acceder directamente a tu solicitud aqu√≠: {benefit_config['path']}"

            first_param = benefit_config["parametros"][0]
            return f"Perfecto, est√°s solicitando **{benefit_config['description']}**. ¬øCu√°l es {first_param['text']}?"

        # Continuar flujo
        parametros = session["parametros"]
        for param in parametros:
            if param["id"] not in session["fields"]:
                session["fields"][param["id"]] = content
                break

        # Verificar si falta alguno
        faltantes = [p for p in parametros if p["id"] not in session["fields"]]
        if faltantes:
            siguiente = faltantes[0]
            return f"¬øCu√°l es {siguiente['text']}?"

        # Completo
        summary = "\n".join([f"- **{k}**: {v}" for k, v in session["fields"].items()])
        path = session["path"]
        del self.benefit_sessions[user_id]

        return f"‚úÖ Aqu√≠ est√° tu solicitud para **{session['benefit']}**:\n{summary}\n\nPuedes enviarla desde: {path}"

    def suggest_routes(self, content: str, role: str, conversation_id: str) -> Dict[str, Any]:
        # Normalizar el texto de entrada
        normalized_content = self.text_normalizer.normalize(content)
        
        # Obtener el estado actual de la conversaci√≥n
        conversation_state = self.conversation_manager.get_or_create_conversation(conversation_id)
        
        # Si ya tenemos un beneficio, procesar el par√°metro actual
        if conversation_state.benefit:
            return self._process_parameter_response(conversation_id, normalized_content)
        
        # Si no tenemos un beneficio, detectarlo
        keywords = self.text_normalizer.get_keywords(normalized_content)
        detected_benefit = self._detect_benefit_combined(normalized_content, keywords)
        
        if detected_benefit:
            # Inicializar la conversaci√≥n con el beneficio detectado
            self.conversation_manager.update_conversation(
                conversation_id, 
                benefit=detected_benefit
            )
            
            # Obtener el primer par√°metro requerido
            next_parameter = self.conversation_manager.get_next_parameter(conversation_id)
            if next_parameter:
                question = FORMS[detected_benefit][next_parameter]
                return {
                    "message": f"Great! You're requesting {detected_benefit}. {question}",
                    "conversation_id": conversation_id,
                    "current_parameter": next_parameter,
                    "benefit": detected_benefit
                }
        
        # Si no se detect√≥ un beneficio, buscar en la base de datos vectorial
        result = self.embedding_service.search_text(normalized_content, CollectionName.NAVIGATION)
        return self._parse_response(result)
    
    def _parse_response(self, results: List[Dict[str, Any]]) -> List[Dict[str, Any]]:
        output = []
        for id_value, metadata, distance in zip(results["ids"][0], results["metadatas"][0], results["distances"][0]):
            output.append({
                  "path": id_value,
                  "description": metadata["short_description"],
                  "score": round((1-distance), 2)
            })
         
        return [output for output in output]

    def _process_parameter_response(self, conversation_id: str, content: str) -> Dict[str, Any]:
        """
        Procesa la respuesta del usuario para el par√°metro actual.
        """
        state = self.conversation_manager.get_or_create_conversation(conversation_id)
        current_parameter = state.current_parameter or self.conversation_manager.get_next_parameter(conversation_id)
        
        if not current_parameter:
            return {
                "message": "I'm not sure what information you're providing. Could you please clarify?",
                "conversation_id": conversation_id,
                "benefit": state.benefit
            }
        
        # Actualizar el par√°metro con la respuesta del usuario
        self.conversation_manager.update_conversation(
            conversation_id,
            parameter=current_parameter,
            value=content
        )
        
        # Verificar si la conversaci√≥n est√° completa
        if self.conversation_manager.is_conversation_complete(conversation_id):
            summary = self.conversation_manager.get_conversation_summary(conversation_id)
            return {
                "message": f"Perfect! I have all the information needed for your {summary['benefit']} request:\n" + 
                          "\n".join([f"- {param}: {value}" for param, value in summary['parameters'].items()]) +
                          "\nWould you like to submit this request?",
                "conversation_id": conversation_id,
                "summary": summary,
                "benefit": summary['benefit'],
                "is_complete": True
            }
        
        # Obtener el siguiente par√°metro
        next_parameter = self.conversation_manager.get_next_parameter(conversation_id)
        if next_parameter:
            question = FORMS[state.benefit][next_parameter]
            return {
                "message": question,
                "conversation_id": conversation_id,
                "current_parameter": next_parameter,
                "benefit": state.benefit
            }
        
        return {
            "message": "I'm not sure what to ask next. Could you please clarify?",
            "conversation_id": conversation_id,
            "benefit": state.benefit
        }

    def _init_benefit_synonyms(self) -> Dict[str, List[str]]:
        """
        Inicializa un diccionario de sin√≥nimos para cada beneficio.
        """
        synonyms = {}
        for benefit in FORMS.keys():
            # Agregar el beneficio original
            synonyms[benefit] = [benefit]
            
            # Agregar sin√≥nimos usando el normalizador
            normalized_benefit = self.text_normalizer.normalize(benefit)
            benefit_synonyms = self.text_normalizer.get_synonyms(normalized_benefit)
            synonyms[benefit].extend(benefit_synonyms)
            
            # Agregar variaciones comunes
            if "vacation" in benefit:
                synonyms[benefit].extend(["holiday", "time off", "leave"])
            elif "gym" in benefit:
                synonyms[benefit].extend(["fitness", "workout", "exercise"])
            elif "days off" in benefit:
                synonyms[benefit].extend(["day off", "personal day", "time off"])
        
        return synonyms

    def _detect_benefit_combined(self, content: str, keywords: List[str]) -> Optional[str]:
        """
        Combina m√∫ltiples m√©todos para detectar beneficios de manera m√°s robusta.
        """
        # 1. Detecci√≥n por palabras clave (m√°s confiable para espa√±ol)
        for benefit, synonyms in self.benefit_synonyms.items():
            # Verificar si alguna palabra clave coincide con los sin√≥nimos
            if any(keyword in synonyms for keyword in keywords):
                return benefit

        # 2. Detecci√≥n por similitud sem√°ntica (si hay embeddings disponibles)
        if self.benefit_embeddings:
            semantic_match = self._semantic_detect_benefit(content)
            if semantic_match:
                return semantic_match

        # 3. Detecci√≥n por coincidencia exacta
        for benefit in FORMS.keys():
            if benefit in content:
                return benefit

        return None

    def _semantic_detect_benefit(self, content: str) -> Optional[str]:
        """
        Detecta beneficios usando similitud sem√°ntica con embeddings.
        """
        if not self.benefit_embeddings:
            return None

        query_embedding = self.embedding_service.generate_embedding(content)

        def cosine_similarity(a, b):
            return dot(a, b) / (norm(a) * norm(b))

        scores = {
            benefit: cosine_similarity(query_embedding, emb)
            for benefit, emb in self.benefit_embeddings.items()
        }

        if not scores:
            return None

        best_match, best_score = max(scores.items(), key=lambda x: x[1])
        return best_match if best_score > 0.65 else None

    def _detect_benefit(self, content: str) -> str or None:
        for benefit in FORMS.keys():
           if benefit in content.lower():
               return benefit            
        return None

    def _init_benefit_embeddings(self):
        from app.shared.forms import FORMS
        self.benefit_embeddings = {
            benefit: self.embedding_service.generate_embedding(benefit)
            for benefit in FORMS.keys()
        }

#  Fase 1: Mejorar la detecci√≥n de beneficios
# ‚úÖ Usar embeddings en lugar de palabras clave (_detect_benefit) para detectar intenciones m√°s naturalmente.
# ‚¨ÜÔ∏è Hacer que reconozca sin√≥nimos, errores ortogr√°ficos o frases largas.
# üí¨ Fase 2: Flujos conversacionales din√°micos
# ‚úÖ Cada beneficio puede tener par√°metros (como fechas, tipo de solicitud, etc).
# üîÅ Hacer preguntas personalizadas seg√∫n el beneficio detectado.
# üíæ Guardar respuestas en sesi√≥n temporal (en memoria por ahora).
# üìù Fase 3: Registro de solicitudes
# üóÉ Guardar cada solicitud en base de datos o archivo (qui√©n pidi√≥ qu√© y cu√°ndo).
# üïµÔ∏è‚Äç‚ôÄÔ∏è Auditar peticiones o generar reportes.
# ü§ñ Fase 4: Integraciones externas
# üí¨ Integrar con Slack, WhatsApp o frontend Web con botones.
# üîî Notificaciones autom√°ticas o correos.
# üì¶ Fase 5: Despliegue y monitoreo
# üê≥ Docker funcional.
# üö¶ Health checks y logs.
# üìä M√©tricas b√°sicas del sistema.